% new chapter for contact models

\chapter{Contact Models}

In an attempt to apply deep learning in a rigid dynamic simulation process, the first step is to understand the details associated with rigid dynamic simulation. Therefore, this chapter focuses on rigid body simulations to help readers understand how computers simulate rigid dynamics based on traditional \textit {Newton-Euler} equations, including how \textit {Newton-Euler} describes rigid dynamics, how to set constraint equations, and numercial solution for dynamic system equation.

\section{Overview}

In rigid body simulation, contact force is used to prevent rigid body from penetrating each other. The accuracy of calculated contact force has great influence on the fidelity of simulation. In order to achieve physical rationality, frictional forces are essential. The formulae of friction contact force problems include the modeling of normal force constraint and friction force constraint. In the future, friction contact force problem will be simply called contact force problem. Before exporting the contact model, it is important to note that the simulation system is constrained by velocity-based location updates\cite{Erleben:2007:VSP:1243980.1243986}. Since collision detection is another big acedamic topic\cite{boulic2007collision} and this is a thesis on contact problems, the following models are given under the assumption that contact determination has already been performed.

\section{Rigid dynamics Simulation}

\subsection{Classical mechanics}
Simulation of the motion of a system of rigid bodies is based on a famous system of differential equations, the \textit{Newton–Euler equations}, which can be derived from Newton’s laws and other basic concepts from classical mechanics:

\begin{enumerate}
    \item Newton’s first law: The velocity of a body remains unchanged r unless acted upon by a force.
    \item Newton’s second law: The time rate of change of momentum of r a body is equal to the applied force.
    \item Newton’s third law: For every force, there is an equal and opposite force.
\end{enumerate}

Before presenting the \textit{Newton–Euler} equations, we need to introduce a number of concepts from classical mechanics. We will start with one simple simulation with only position vector $\pmb{q}(t)$ and velocity vector $\pmb{v}(t)$. Then, we will introduce some concepts by adding rotatiopn to pure simulation, rotational velocity $\pmb{\omega}(t)$, and moment $\pmb{\tau}$ (also known as a torque).


\subsection{Simulation Basics}

Firstly, we can start with a simple simulation with only position and velocity. Simulating the motion of a rigid body is almost the same as simulating the motion of a particle, so I will start with partcle simulation. For particle simulation, we let function $\pmb{q}(t)$ describe the particle's location in world space at time $t$. Then we use the change of $\pmb{q}(t)$
to denote the velocity of the particle at time $t$. 
\begin{equation}
    \pmb{v}(t) = \dot{\pmb{q}}(t)
\end{equation}
So, the state of a particle at a time $t$ is the particle's position and velocity. We generalize this concept by defining a state vector $\textbf{Y}(t)$ for a system: for a single particle,
\begin{equation}
    \textbf{Y}(t) = \left[
        \begin{array}{c}
            \pmb{q}_{1}(t) \\
            \pmb{v}_{1}(t) \\
        \end{array}
    \right]
\end{equation}

For a system with $n$ particles, we enlarge $\textbf{Y}(t)$ to be
\begin{equation}
    \textbf{Y}(t) = \left[
    \begin{array}{c}
        \pmb{q}_{1}(t) \\
        \pmb{v}_{1}(t) \\
        ... \\
        \pmb{q}_{n}(t) \\
        \pmb{v}_{n}(t) \\
    \end{array}
    \right]
\end{equation}

However, to simulate the motion of particles actually, we need to know one more thing -- the forces. $\pmb{f}(t)$ is defined as the force acting on the particle. If the mass of the particle is $m$, then the changes of $\textbf{Y}(t)$ will be given by
\begin{equation}
    \dot{\mathbf{Y}}(t) = \frac{\dif}{\dif(t)}\textbf{Y}(t) = \frac{\dif}{\dif(t)}\left[
        \begin{array}{c}
            \pmb{q}(t) \\
            \pmb{v}(t) \\
        \end{array} \right] = \left[
        \begin{array}{c}
            \pmb{v}(t) \\
            \pmb{f}(t)/m \\
        \end{array} \right]
\end{equation}

\subsection{Rigid Body Concepts}
Unlike a particle, a rigid body occupies a volume of space and has a particular shape. Rigid bodies are more complicated, beside translating them, we can rotate them as well. To locate a rigid body, we use $\pmb{q}(t)$ to denote their translation and a rotation matrix $\pmb{R}(t)$ to describe their rotation.

\subsection{Rigid Body Equations of Motions}
\label{sec:rigid_rm}
 Whereas linear momentum $\pmb{P}(t)$ is related to linear velocity with a scalar (the mass), angular momentum is related to angular velocity with a matrix \(\pmb{I}\), called the angular inertia matrix. The reason for this is that objects generally have different angular inertias around different axes of rotation. Angular momentum is defined as \(\pmb{L}\). The linear momentum and angular momentum are defined in Equation \ref{mom}.
\begin{subequations}
\begin{align}
    m \dot{\pmb{v}}(t) = \pmb{f}(t) & \\
    \pmb{P}(t) = m \pmb{v} (t)  & \\
    \pmb{L}(t) = \pmb{I}(t)\pmb{\omega}(t) & 
\end{align}
\label{mom}
\end{subequations}

The total torque $\pmb{\tau}$ applied to the body is equal to the rate of change of the angular momentum, as defined in \ref{tau}:
\begin{equation}
    \pmb{\tau} = \frac{\dif}{\dif t }\pmb{L} = \frac{\dif}{\dif t }(\pmb{I}\pmb{\omega})
    \label{tau}
\end{equation}

 Then we can covert all concepts we need to define stare $\textbf{Y}$ for a rigid body.

\begin{equation}
    \textbf{Y}(t) = \left[
        \begin{array}{c}
            \pmb{q}(t) \\
            \pmb{R}(t) \\
            \pmb{P}(t) \\
            \pmb{L}(t) \\
        \end{array}
    \right]
\end{equation}

Like what is expressed in $\textbf{Y}(t)$, the state of a rigid body is mainly consist by its position and orientation (describing spatial information), and its linear and angualr momentum(describe velocity information). Since mass $m$ and bodyspace inertia tensor $\pmb{I}_{body}$ are constants, we can the auxiliary quantities $\pmb{I}(t)$, $\pmb{\omega}(t)$ at any given time.
\begin{subequations}
\begin{align}
    \pmb{v}(t) & = \frac{\pmb{P}(t)}{m} \quad \\
    \pmb{I}(t) & = \pmb{R}(t)\pmb{I}_{body}\pmb{R}(t)^{T} \quad \\
    \pmb{\omega}(t) & = \pmb{I}(t)^{-1}\pmb{L}(t) 
\end{align}
\end{subequations}

Then, the derivative $\dot{\textbf{Y}}(t)$ is
\begin{equation}
    \dot{\textbf{Y}}(t) = \frac{\dif}{\dif{t}}\textbf{Y}(t) = \frac{\dif}{\dif t}\left[
        \begin{array}{c}
            \pmb{q}(t) \\
            \pmb{R}(t) \\
            m \pmb{v}(t) \\
            \pmb{L}(t) \\
        \end{array}
    \right] = \left[
        \begin{array}{c}
            \pmb{v}(t) \\
            \pmb{\omega}(t)\times\pmb{R}(t) \\
            \pmb{f}(t) \\
            \pmb{\tau}(t) \\
        \end{array}
    \right]
\end{equation}

Then, we can evaluate Equation \ref{tau_ev} as follows:
\begin{equation}
    \begin{aligned}
        \pmb{\tau} &= \frac{\dif}{\dif t}(\pmb{I}\pmb{\omega}) \\
        &= \pmb{I}\dot{\pmb{\omega}} + \dot{\pmb{I}}\pmb{\omega} \\
        &= \pmb{I}\dot{\pmb{\omega}} + \frac{\dif}{\dif t}(\pmb{R}\pmb{I}_{body}\pmb{R}^{T})\pmb{\omega} \\
        &= \pmb{I}\dot{\pmb{\omega}} + (\dot{\pmb{R}}\pmb{I}_{body}\pmb{R}^{T} + \pmb{R}\pmb{I}_{body}\dot{\pmb{R}}^{T})\pmb{\omega} \\
        &= \pmb{I}\dot{\pmb{\omega}} + ([\pmb{\omega}]\pmb{R}\pmb{I}_{body}\pmb{R}^{T} + \pmb{R}\pmb{I}_{body}\pmb{R}^{T} \hat{\pmb{\omega}})\pmb{\omega} \\
        &= \pmb{I}\dot{\pmb{\omega}} + [\pmb{\omega}]\pmb{I}\pmb{\omega} - \pmb{I}[\pmb{\omega}]\pmb{\omega}
    \end{aligned}
    \label{tau_ev}
\end{equation}

Since $\pmb{\omega} \times \pmb{\omega}$ is zero, the final term can be cancels out. This relationship left is knowned as :
\begin{equation}
    \pmb{\tau} = \pmb{I}\dot{\pmb{\omega}} + [\pmb{\omega}]\pmb{I}\pmb{\omega}
    \label{tau}
\end{equation}

\subsection{Twist/Wrench}
Twist is introduced to describe linear and angular velocity, and wrenches, which describe forces, and explain how these objects transform from one coordinate frame to another one. 
    \subsubsection{Twist} 
        A twist is a vector that expresses rigid motion or velocity. In Section \ref{sec:rigid_rm}, we saw how to parameterize the velocity of a rigid body as a linear velocity vector and an angular velocity vector. The coordinates of a twist are given as a 4-vector in $2$-D simulation, which we can check in \ref{twist}
            \begin{equation}
                \mathbf{v} = \left[ \begin{array}{c} \pmb{\omega} \\ \pmb{v} \\ \end{array} \right]
                \label{twist}
            \end{equation}.
        The defination can be found in \ref{twist}, containing a linear velocity vector \(\pmb{v}\) and an angular velocity \(\pmb{\omega}\). According to 

    \subsubsection{Wrench}
        A wrench is a vector that expresses force and torque acting on a body. A wrench can be defined by
        \begin{equation}
            \mathbf{f} = \left[ \begin{array}{c} \pmb{\tau} \\ \pmb{f} \\ \end{array} \right]
            \label{wrench} 
        \end{equation}

        A wrench contains an angular component $\pmb{\tau}$ and a linear component $f$, which are applied at the origin of the coordinate frame they are specified in.


\subsection{Newton-Euler Equation}
    \textit{Newton-Euler} equations for a rigid body can now be written in terms of the body's acceleration twist $\mathbf{v}$ methioned in \ref{twist} and the wrench $\mathbf{f}$ metioned in \ref{wrench} acting on the body. We can simply write the Newton and Eular equations,

    \begin{equation}
        \left[ \begin{array}{c} \pmb{\tau} - \pmb{\omega} \times \pmb{I} \pmb{\omega}\\ \pmb{f} \end{array}\right] = \left[ \begin{array}{cc} \pmb{I} & \pmb{0} \\ \pmb{0}& m\pmb{1}_{d\times d}\end{array} \right] \dot{\mathbf{v}}
    \end{equation}
    $d$ stands for the number pf dimensions, like $d=2$ in $2$-\textit{D} and $3$ in $3$-\textit{D}. \\

    Then, we can rewrite \textit{Newton-Euler} equation as,
    \begin{equation}
        \pmb{M}\dot{\mathbf{v}} = \mathbf{F}
        \label{eq:newton}
    \end{equation}
    where $\pmb{M}$ and $\mathbf{h}$ are defined in Equation \ref{M} and \ref{F}.
    \begin{equation}
        \pmb{M} = \left[ \begin{array}{cc} \pmb{I} & \pmb{0} \\ \pmb{0} & m\pmb{1}_{d \times d}\end{array} \right]
        \label{M}
    \end{equation}
    \begin{equation}
        \mathbf{F} = \left[ \begin{array}{c} \pmb{\tau} - \pmb{\omega} \times \pmb{I} \pmb{\omega}\\ \pmb{f} \end{array}\right]
        \label{F}
    \end{equation}


\section{Velocity-based conatct model}
    After get some basic physical and mathematical knowledge about dynamic system. Then,  the next step is to describe the equation of motion for system with contact forces.  \\

    When collision happens, we can use contact forces to model the interactions between two colliding objects. The contact forces consist of both normal forces and frictional forces, which are subject to a set of constraints. The constraints are defined in Equation \ref{eq:constraint}.
    \begin{equation}
        \pmb{c}(\pmb{q}) = [c_1(\pmb{q}),c_2(\pmb{q}),...,c_n(\pmb{q})]
        \label{eq:constraint}
    \end{equation}

    the Jacobian, $\pmb{J}_{c}$ of Equation \ref{eq:constraint} is,
    \begin{equation}
        \pmb{J}_{c} = 
        \begin{bmatrix}
            \frac{\partial{c_1}}{\partial{q_1}} & \frac{\partial{c_2}}{\partial{q_1}} & ... & \frac{\partial{c_n}}{\partial{q_1}} \\
            \frac{\partial{c_1}}{\partial{q_2}} & \frac{\partial{c_2}}{\partial{q_2}} & ... & \frac{\partial{c_n}}{\partial{q_2}} \\
            \vdots & \vdots & & \vdots\\
            \frac{\partial{c_1}}{\partial{q_n}} & \frac{\partial{c_2}}{\partial{q_n}} & ... & \frac{\partial{c_n}}{\partial{q_n}} \\
        \end{bmatrix}
        \label{Jacobianb}
    \end{equation}

    The constraints are added to Equation \ref{eq:newton} by applying the Lagrange multiplier method such that,
    \begin{equation}
        \pmb{M}\dot{\mathbf{v}} = \pmb{J}_{c}^{T}\pmb{\lambda} + \mathbf{F}_{ext}
        \label{eq:cone}
    \end{equation}
    where $\pmb{\lambda} = [\lambda_1, \lambda_2, ... , \lambda_n]^T$ are the Lagrange multipliers.

\subsection{Linear Comlementarity Problem}
    (LCP): Given an unknown vector $\mathbf{x} \in \mathbb{R}^{m}$, a known fixed matrix $\pmb{A} \in \mathbb{R}^{m\times m}$, and a known fixed vector $\pmb{b} \in \mathbb{R}^{m}$, determine $\mathbf{x}$ such that,
    \begin{equation}
        f(\mathbf{x}) = \mathbf{x}^{T}(\pmb{A}\cdot\mathbf{x} + \pmb{b}) = 0
    \end{equation}
    subject to the constraints,
    \begin{subequations}
    \begin{align}
        \pmb{A}\cdot\mathbf{x} + \pmb{b} \ge \pmb{0} & \\
        \mathbf{x} \ge \pmb{0} &
    \end{align}
    \end{subequations}
    \textit{For LCPs, we adopt the shorthand notation, LCP($\pmb{A}, \pmb{b}$)}.


\subsection{Modeling contact}
    The contact force problem can be stated as a linear complementarity problem (LCP)\cite{bender2014interactive}. However, a slightly different formulation is used in interactive physical simulations, we will derive this formulation. Without loss of generality, we will only consider a single contact point. The focus of this chapter is on the contact force model, so the time stepping scheme and matrix layouts are based on the velocity-based formulation. Then we can rewirte the \textit{Newton–Euler} equations based on Equation \ref{eq:cone},

    \begin{equation}
        \pmb{M}\dot{\mathbf{v}} = \pmb{J}_{n}^{T}\lambda_n + \pmb{J}_{t}^{T}\lambda_{t} + \mathbf{F}_{ext}
    \end{equation}

    then we can get,

    \begin{equation}
        \dot{\mathbf{v}} = \pmb{M}^{-1}\mathbf{F}_{ext} + \pmb{M}^{-1}\pmb{J}_{n}^{T}\lambda_{n} + \pmb{M}^{-1}\pmb{J}_{t}^{T}\lambda_{t}
        \label{sys}
    \end{equation}

    Let the Lagrange multipliers $\pmb{\lambda} = [\lambda_n~\lambda_t]^{T}$ and contact Jacobian $\pmb{J} = [\pmb{J}_n, \pmb{J}_{t}]$, then we can rewrite Equation \ref{sys} as, 
    \begin{equation}
        \dot{\mathbf{v}} = \pmb{M}^{-1}\pmb{J}^{T}\pmb{\lambda} + \pmb{M}^{-1}\mathbf{F}_{ext}
    \end{equation}
    The laws of physics must be incorporated into what we call ``instantaneous time'', which describes the continuous motion of the rigid bodies. After that, we discretize the model over time to obtain a `discrete-time' model, which is a series of time step sub-problems. Sub-problems are formulated and numerically solved at each time step to simulate the system.\\
    
    To discretize the system \ref{sys}, the acceleration can be approximated by \cite{anitescu1997modeling} as:
    \begin{equation}
        \dot{\mathbf{v}} \approx \frac{(\mathbf{v}_{t+1} - \mathbf{v}_t)}{\Delta t}
    \end{equation}
    $\mathbf{v}_t$ and $\mathbf{v}_{t+v}$ are the velocities at the beginning of the current time step, and the next time step, $\Delta t$ is the time step. Then we can get,
    \begin{equation}
        \mathbf{v}^{t+1} = \mathbf{v}^{t} + \pmb{M}^{-1}\pmb{J}^{T}\Delta{t}\pmb{\lambda} + \Delta{t}\pmb{M}^{-1}\mathbf{F}_{ext}
    \end{equation}

    Then we can define,
    \begin{equation}
    \begin{aligned}
        \mathbf{w} & = \pmb{J}\mathbf{v}^{t+1} \\
        & =  \underbrace{\pmb{J}\pmb{M}^{-1}\pmb{J}^{T}\Delta{t}}_{\pmb{A}}\pmb{\lambda} + \underbrace{\pmb{J}(\Delta{t}\pmb{M}^{-1}\mathbf{F}_{ext} + \mathbf{v}^{t})}_{\pmb{b}} \\
        & = \pmb{A}\pmb{\lambda} + \pmb{b}
        \label{lcp}
    \end{aligned} 
    \end{equation}
    Also,
    \begin{equation}
        \mathbf{w} = \pmb{J}\mathbf{v} = \frac{\dif{\pmb{c}}}{\dif{\pmb{q}}}\frac{\dif{\pmb{q}}}{\dif{t}} = \dot{\pmb{c}}
    \end{equation}
    Based on physics law,
    $$\pmb{\lambda}^{T} \dot{\pmb{c}} = 0$$
    So Equation \ref{lcp} can be considered as one LCP. So finally, contact model is to find solution for,
    $$\pmb{\lambda} = \textit{LCP}(\pmb{A}, \pmb{b})$$
    However, when friction is added the model, the system will be more comlecated due to Coulomb’s friction law. Some other constraint(e.g. $-\mu \lambda_{n} \le \lambda_t \le \mu \lambda_n$) will be imported to find a solution. Since the focus of paper is on find a solution by deep learning, I did not explore too much on frictinal contact model. I recommend Sarah and Kenny's paper \cite{poulsen2010heuristic} to know more details. 

\section{The Numercial Solution Method}
    After obtaining discrete-time models, numerical methods must be applied to compute solutions. Normally, iterative solution will be used to solve LCP. 

    \subsection{Projected Gauss–Seidel(PGS) solver for contact forces}
    One of the most classic methos is projected gauss-seidel(PGS). Most open-source software for interactive real-time rigid body simulation uses the Projected Gauss–Seidel (PGS) method for computing contact forces has been widely used by many open-source software and computer physics engine, like \textit{Box2D}\footnote{\url{http://box2d.org/}} for 2-$D$ and \textit{Bullet}\footnote{\url{https://pybullet.org/wordpress/}} for 3-$D$. PGS is computationally very efficient with an iteration cost of $O(n)$, using a careful memory layout of sparse matrices allows for a memory footprint of $O(n)$. In addition to being computationally and memory-wise efficient, PGS is very robust and can deal gracefully with ill-conditioned problems (due to many redundant constraints) or ill-posed problems (due to badly defined constraints). For these reasons, PGS is well suited for interactive applications like computer games. I introduced PGS in Algorithm \ref{pgs}. Generally, $\lambda_{init} = \pmb{0}$, and some experiment will be done to explore its covergence rate in section \ref{sphtest}.
    \begin{algorithm}[!h]
        \KwData{$N, \pmb{\lambda}, \pmb{A}, \pmb{b}$}
        \KwResult{Compute the values of $\pmb{\lambda}$}
        \For{$ k = 1~\textbf{To}~N$}{
            \For{all $i$}{
                $\pmb{r}_i \gets \pmb{A}_{i*}\pmb{\lambda} + \pmb{b}_i$ \;
                $\pmb{\lambda}_{i} \gets \text{max}(0, \pmb{\lambda}_i - \frac{\pmb{r}_i}{\pmb{A}_{ii}})$ \;
            }
        }
        \caption{\textit{pgs}($\pmb{A}, \pmb{b}, \pmb{\lambda}$)}
        \label{pgs}
    \end{algorithm}

    As a conclusion, iterative solver will be use to solve LCP problem. Our hope is to find values which are close to the final solution by deep learning. Then the closing values will be used as initial values so that iterative solve can converage rapidly.